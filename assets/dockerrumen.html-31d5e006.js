import{_ as e,o,c as r,d as c}from"./app-e09b6429.js";const d="/orangewind/images/docker/docker.png",n="/orangewind/images/docker/dockerServer.png",i="/orangewind/images/docker/dockerEngine.png",a={},s=c('<h2 id="docker是什么" tabindex="-1"><a class="header-anchor" href="#docker是什么" aria-hidden="true">#</a> docker是什么</h2><p><img src="'+d+'" alt=""></p><ul><li>docker是一个可以创建、管理<strong>容器</strong>的东西。可以理解为docker里面存放了许多<strong>容器</strong>。</li><li><strong>容器</strong>就是一个精简版的linux系统，这个系统只有基本的环境供以使用，里面可以运行程序(可以是mysql，可以是nginx，可以是redis等)。</li><li><strong>容器</strong>的创建是依赖于<strong>镜像</strong>的，<strong>镜像</strong>可以看作是一个模板，docker可以根据镜像生成一个容器实例，假如你需要一个<strong>容器</strong>中放入mysql，那么就去docker的<strong>镜像</strong>仓库拉取一个mysql<strong>镜像</strong>(可指定版本)，然后docker可以基于这个<strong>镜像</strong>创建一个mysql<strong>容器</strong>，这样就能在docker中运行使用一个只含有mysql的系统了。</li><li><strong>容器</strong>的存在使我们可以方便做很多事情，比如项目需要mysql、nginx环境来运行，可以直接创建mysql和nginx<strong>容器</strong>供项目使用，不需要在服务器上下载、安装、配置这些环境，<strong>容器</strong>内部已经包含了这些必备的东西。同时<strong>容器</strong>还可以很方便的移植，比如我们需要切换服务器，这些项目正在使用的<strong>容器</strong>可以直接打包带走放在另一个服务器上。</li></ul><h2 id="docker的用途" tabindex="-1"><a class="header-anchor" href="#docker的用途" aria-hidden="true">#</a> docker的用途</h2><p>Docker 的主要用途，目前有三大类。</p><ol><li>**提供一次性的环境。**比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>**提供弹性的云服务。**因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li>**组建微服务架构。**通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ol><h2 id="docker的基本概念" tabindex="-1"><a class="header-anchor" href="#docker的基本概念" aria-hidden="true">#</a> docker的基本概念</h2><p>镜像(<code>Image</code>)、容器(<code>Container</code>)与仓库(<code>Repository</code>)，这三个是<code>docker</code>中最基本也是最核心的概念。</p><h3 id="镜像-image" tabindex="-1"><a class="header-anchor" href="#镜像-image" aria-hidden="true">#</a> 镜像(Image)</h3><p><code>Docker 把应用程序及其依赖，打包在 image 文件里面。</code>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><h3 id="容器-container" tabindex="-1"><a class="header-anchor" href="#容器-container" aria-hidden="true">#</a> 容器(Container)</h3><p><code>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</code>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><h3 id="仓库-repository" tabindex="-1"><a class="header-anchor" href="#仓库-repository" aria-hidden="true">#</a> 仓库(Repository)</h3><p><code>Docker Hub</code>就是Docker提供用于存储和分布镜像的官方<code>Docker Registry</code>，也是默认的<code>Registry</code>，其网址为<code>https://hub.docker.com</code>，前面我们使用<code>docker pull</code>命令便从<code>Docker Hub</code>上拉取镜像。</p><h2 id="docker的组成与架构" tabindex="-1"><a class="header-anchor" href="#docker的组成与架构" aria-hidden="true">#</a> docker的组成与架构</h2><p><img src="'+n+'" alt=""></p><h3 id="docker-engine" tabindex="-1"><a class="header-anchor" href="#docker-engine" aria-hidden="true">#</a> docker Engine</h3><p><code>docker server</code>为客户端提供了容器、镜像、数据卷、网络管理等功能，其实，这些功能都是由<code>Docker Engine</code>来实现的。</p><ol><li><code>dockerd</code>:服务器守护进程。</li><li><code>Client docker Cli</code>：命令行接口</li><li><code>REST API</code>：除了cli命令行接口，也可以通过<code>REST API</code>调用<code>docker</code></li></ol><p><img src="'+i+'" alt=""></p>',20),t=[s];function g(l,h){return o(),r("div",null,t)}const m=e(a,[["render",g],["__file","dockerrumen.html.vue"]]);export{m as default};
